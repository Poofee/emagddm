# 第三方库集成规范

严格遵循前期指定的第三方库选型，按"轻量优先、解耦封装、按需集成"原则集成，禁止随意替换库、添加库。

## 库集成原则

### 单头文件库
- 直接放入 lib/ 对应目录，通过 #include 直接引用
- 无需额外编译、链接
- 示例：nlohmann/json、spdlog

### 轻量开源库
- 放入 lib/ 对应目录
- 在 CMake 中指定头文件路径、链接库文件
- 禁止修改库源码
- 示例：Eigen、Gmsh API

### 并行/数值库
- 优先使用系统安装的库
- 若需预编译，放入 lib/ 对应目录，提供 Linux/Windows 双版本预编译库
- 示例：OpenMPI、SuperLU、PETSc

## 库调用规范

### 解耦封装
- 所有第三方库的调用，均封装在底层模块（tool/、numeric/）
- 提供统一的抽象接口，上层模块（fetidp/、app/）不直接调用库API

**正确示例**：上层模块调用 numeric::SparseMatrix 的 multiply 方法，底层封装 Eigen::SparseMatrix 的乘运算。

**错误示例**：上层模块直接调用 Eigen::SparseMatrix::operator* 进行矩阵乘。

### 版本兼容
- 确保集成的库版本与前期指定一致（如Eigen 3.4+、OpenMPI 4.0+）
- 禁止使用高版本库的专属特性，避免兼容性问题

### 错误处理
- 库调用失败时（如Gmsh网格读取失败、SuperLU分解失败），需捕获错误信息
- 通过spdlog输出ERROR日志，明确失败原因，避免程序崩溃

## 禁止集成的库

禁止集成以下库，避免增加工程复杂度、编译难度：

- 商业库（如Intel MKL，除SuperLU外，优先使用开源替代方案）
- 小众库、未维护库（如不知名的稀疏矩阵库、配置解析库）
- 依赖过多的库（如Qt，仅用于界面，本框架无需界面）