# 电磁项目数据统一：全量数据管理与兼容方案

要实现电磁项目中**材料、设置、边界、网格、几何、激励、求解结果**等全量数据的统一保存与管理，核心遵循**「分层结构化建模+双格式存储体系+单例管理器统一入口+全生命周期数据管控」** 四大原则，同时贴合前序的2D/3D抽象架构、第三方求解器适配设计，保证**数据解耦、格式兼容、操作便捷、可移植性强**，既对标Maxwell的项目文件管理逻辑，又适配自研框架的工程化需求（增量修改、批量处理、跨维度复用）。

整体设计围绕**「一个核心管理器+一套结构化数据模型+两种存储格式+全链路数据API」** 展开，将项目中分散的各类数据有序组织、关联管理，屏蔽底层存储细节，让上层模块/用户仅通过统一接口实现数据的加载、保存、修改，同时解决**数据一致性、大文件高效存储、Maxwell兼容、可移植性**四大核心痛点，以下是落地式设计方案，包含**数据分层模型、存储格式选型、核心数据管理逻辑、全生命周期操作、Maxwell兼容方案**，完全适配电磁模块的所有数据类型。

## 一、核心设计原则（先定规则，避免数据混乱）

在具体设计前明确6条核心原则，所有数据管理逻辑均围绕这些原则展开，保证架构的一致性和可扩展性：

1. **数据解耦，分层管理**：不同类型数据（如材料、边界）独立建模，通过**全局唯一ID**建立关联，不混存、不耦合，便于增量修改和模块复用；

2. **接口统一，屏蔽细节**：所有数据操作（加载/保存/修改）均通过**ProjectManager**单例管理器完成，上层模块/用户不直接操作文件，屏蔽序列化、格式转换、文件IO细节；

3. **双格式适配，兼顾易用与效率**：**明文结构化格式（JSON/YAML）** 存配置、材料、边界等小体积结构化数据（易编辑、调试、跨平台），**二进制格式**存网格、节点、拓扑等大体积数据（高存储效率、快加载速度）；

4. **全量+增量，兼顾完整与高效**：支持**全量保存/加载**（整项目一键存储）和**增量修改/保存**（仅更新修改的部分数据，无需重写整个文件）；

5. **ID唯一，关联一致**：为所有几何、材料、边界、网格、激励分配**全局唯一ID**，通过ID映射表建立数据关联（如「几何ID-材料ID」「几何ID-边界ID」），保证数据一致性；

6. **兼容Maxwell，无缝迁移**：支持解析Maxwell导出的标准化数据（XML/TXT），自动转换为框架内部数据模型，同时支持框架结果导出为Maxwell兼容格式。

## 二、第一步：构建「分层结构化数据模型」

项目中所有数据按**「用途+关联关系+存储特性」** 分为4层，每层设计**独立的结构化数据类**，所有数据类均继承**统一的序列化接口**（ISerializable），实现**格式无关的序列化/反序列化**，让底层存储格式变化时，上层数据类无需大幅修改。

### 1. 数据分层体系（从核心到辅助，层层关联）

四层数据完全解耦，通过**全局唯一ID**和**映射表**建立关联，整体结构清晰，便于维护和扩展，同时与电磁模块的**材料、边界、网格、维度抽象**等子模块一一对应：

```Plain Text

┌──────────────────────── 项目文件（*.emf） ───────────────────────┐
│  ┌────────── 第一层：配置元数据（ProjectMeta） ───────────┐      │
│  │  项目基础信息：名称/ID/创建时间/修改时间/版本号/维度/场型  │      │
│  │  框架配置：求解器类型/并行模式/单位体系/日志级别          │      │
│  └───────────────────────────────────────────────────────┘      │
│  ┌────────── 第二层：核心业务数据（CoreBusinessData） ──────┐      │
│  │  ├─ 材料数据（MaterialDataList）：所有材料的结构化信息    │      │
│  │  ├─ 几何数据（GeometryData）：几何拓扑/实体ID/形心/尺寸   │      │
│  │  ├─ 边界数据（BoundaryDataList）：所有边界的类型/参数/关联几何 │
│  │  ├─ 激励数据（ExcitationDataList）：所有激励的类型/参数/关联几何 │
│  │  └─ 网格配置（MeshConfigData）：网格划分参数/加密规则/单元类型 │
│  └───────────────────────────────────────────────────────┘      │
│  ┌────────── 第三层：计算过程数据（ProcessData） ──────────┐      │
│  │  网格拓扑数据（MeshTopologyData）：节点/单元/局部-全局DOF映射 │
│  │  DOF管理数据（DOFData）：全局DOF数/约束DOF/周期性映射     │      │
│  │  矩阵配置数据（MatrixData）：矩阵类型/非零元数/存储格式    │      │
│  └───────────────────────────────────────────────────────┘      │
│  ┌────────── 第四层：计算结果数据（ResultData） ───────────┐      │
│  │  场量结果：节点/积分点的场量值（电位/磁势/B/H/E）        │      │
│  │  工程指标：电容/电感/损耗/电磁力/力矩等计算结果           │      │
│  │  求解过程：迭代次数/残差曲线/耗时/收敛状态                │      │
│  └───────────────────────────────────────────────────────┘      │
│  ┌────────── 关联映射表（MapTable） ──────────────────────┐      │
│  │  核心关联：EntityID→MaterialID、EntityID→BoundaryIDList │      │
│  │  计算关联：UnitID→EntityID、UnitID→GlobalDOFList        │      │
│  └───────────────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────────┘
```

### 2. 统一序列化接口（ISerializable）

所有数据类均继承该接口，强制实现**序列化（转存储格式）和反序列化（从存储格式解析）方法，让JSON/YAML/二进制的转换逻辑内聚在数据类中，实现格式与数据的解耦**：

```C++

// 序列化格式枚举（全局统一）
enum class SerializeFormat { JSON, YAML, BINARY };

// 统一序列化接口（纯虚，所有数据类继承）
class ISerializable {
public:
    virtual ~ISerializable() = default;
    // 序列化：将数据类转为指定格式的字节流/字符串
    virtual std::vector<char> serialize(SerializeFormat fmt) const = 0;
    // 反序列化：从指定格式的字节流/字符串解析为数据类
    virtual bool deserialize(const std::vector<char>& data, SerializeFormat fmt) = 0;
};
```

### 3. 核心数据类示例（贴合工程需求，结构化建模）

以**材料、边界、网格**这三个核心数据为例，设计结构化数据类，包含**工程所需的全量属性**，同时实现序列化接口，其他数据类（激励、几何、结果）按相同规则设计：

#### （1）材料数据类（MaterialData）

包含线性/非线性/各向同性/各向异性的全量属性，关联**材料ID**（主键），支持B-H曲线/磁化曲线的外部文件关联或内嵌：

```C++

// 材料特性枚举
enum class MatType { LINEAR, NONLINEAR };       // 线性/非线性
enum class MatSymmetry { ISOTROPIC, ANISOTROPIC };// 各向同性/各向异性
enum class MatField { ELECTROSTATIC, MAGNETOSTATIC, TRANSIENT };// 适配场型

// 材料结构化数据类（实现序列化接口）
class MaterialData : public ISerializable {
public:
    std::string mat_id;        // 全局唯一材料ID（主键，如"Copper_001"）
    std::string mat_name;      // 材料名称（如"铜"）
    MatType mat_type;          // 材料类型
    MatSymmetry mat_sym;       // 对称性
    std::vector<MatField> fit_fields; // 适配场型
    // 基础电磁参数（线性/各向同性为标量，各向异性为矩阵）
    double er;                 // 相对介电常数
    double mur;                // 相对磁导率
    double sigma;              // 电导率
    Eigen::Matrix3d er_mat;    // 介电常数张量（各向异性）
    Eigen::Matrix3d mur_mat;   // 磁导率张量（各向异性）
    // 非线性参数
    std::string bh_curve_path; // B-H曲线文件路径（外部）
    std::vector<std::pair<double, double>> bh_curve_data; // B-H曲线数据（内嵌）
    double b_sat;              // 饱和磁通密度
    // 工程辅助参数
    double curie_temp;         // 居里温度
    std::string unit;          // 单位体系（国际/工程）

    // 实现序列化接口
    std::vector<char> serialize(SerializeFormat fmt) const override {
        // 内部实现：按JSON/YAML/BINARY将所有成员变量序列化
    }
    bool deserialize(const std::vector<char>& data, SerializeFormat fmt) override {
        // 内部实现：从字节流解析为成员变量，做参数校验
    }
};
// 材料列表类（管理所有材料）
class MaterialDataList : public ISerializable {
public:
    std::unordered_map<std::string, MaterialData> mat_map; // 材料ID→材料数据（快速查找）
    // 实现序列化接口...
};
```

#### （2）边界数据类（BoundaryData）

包含边界类型、参数、关联几何对象，关联**边界ID**（主键）和**几何ID**（外键），支持场型专属边界，与边界管理模块一一对应：

```C++

// 边界类型枚举（对齐Maxwell）
enum class BndType { DIRICHLET, NEUMANN, PERIODIC, SYMMETRIC, FAR_FIELD };
// 边界结构化数据类
class BoundaryData : public ISerializable {
public:
    std::string bnd_id;        // 全局唯一边界ID（主键）
    std::string bnd_name;      // 边界名称（如"0电位边界"）
    BndType bnd_type;          // 边界类型
    std::vector<std::string> link_entity_ids; // 关联几何ID（面/边/体，支持多几何）
    MatField fit_field;        // 适配场型（如静磁场专属磁绝缘）
    bool is_active;            // 激活状态（便于增量修改，临时关闭边界）
    // 边界参数（按类型动态存储，如Dirichlet为固定值，Neumann为法向导数）
    std::unordered_map<std::string, double> bnd_params; // 如{"value":0.0, "tol":1e-6}

    // 实现序列化接口...
};
// 边界列表类
class BoundaryDataList : public ISerializable {
public:
    std::unordered_map<std::string, BoundaryData> bnd_map; // 边界ID→边界数据
    // 实现序列化接口...
};
```

#### （3）网格拓扑数据类（MeshTopologyData）

大体积数据，包含节点、单元、拓扑关联，专为**二进制序列化**设计，兼顾存储效率和加载速度，与2D/3D维度抽象架构的网格模块对接：

```C++

// 网格拓扑数据类（大体积，优先二进制序列化）
class MeshTopologyData : public ISerializable {
public:
    // 节点数据：节点ID→三维坐标（2D/轴对称的z坐标为0，统一3D存储，简化维度适配）
    std::unordered_map<std::string, Eigen::Vector3d> node_map;
    // 单元数据：单元ID→单元类型/所属实体ID/局部节点ID列表/局部DOF数
    struct UnitInfo {
        std::string unit_type; // 如"3D_TET4"（3D四面体4节点）
        std::string entity_id; // 所属几何实体ID
        std::vector<std::string> node_ids; // 局部节点ID列表
        int local_dof_num;     // 局部DOF数
    };
    std::unordered_map<std::string, UnitInfo> unit_map;
    // 局部-全局DOF映射：单元ID→全局DOF列表（对接DOF管理模块）
    std::unordered_map<std::string, std::vector<int>> unit2dof_map;

    // 实现序列化接口：优先二进制，JSON/YAML仅做兼容
    std::vector<char> serialize(SerializeFormat fmt) const override {
        if (fmt == SerializeFormat::BINARY) {
            // 二进制序列化：按固定格式写入，高效压缩
        } else {
            // JSON/YAML序列化：仅用于调试，大体积数据不推荐
        }
    }
    bool deserialize(const std::vector<char>& data, SerializeFormat fmt) override {
        // 对应反序列化逻辑...
    }
};
```

## 三、第二步：设计「双格式混合存储体系」

结合不同数据的**存储特性**和**工程需求**，采用**「明文结构化格式（JSON/YAML）+ 二进制格式」** 的混合存储方案，同时将所有文件打包为**单文件项目包（*.emf）**（本质是轻量压缩包），避免零散文件，提升可移植性，完全对标Maxwell的单文件项目管理逻辑。

### 1. 两种格式的分工（按需选择，兼顾易用与效率）

|存储格式|适用数据类型|核心优势|序列化/反序列化对象|
|---|---|---|---|
|**JSON/YAML**|配置元数据、材料、边界、激励、网格配置、关联映射表、工程指标|明文可编辑、易调试、跨平台、小体积、易解析|所有小体积结构化数据类|
|**二进制**|网格拓扑、节点/单元数据、场量结果、大体积矩阵数据|存储效率高、加载速度快、压缩比高、适合大体积|网格拓扑、结果数据等大体积类|
### 2. 单文件项目包（*.emf）内部结构

框架原生项目文件为***.emf**（ElectroMagnetic Framework），本质是**ZIP轻量压缩包**，内部包含3个核心文件，结构固定，便于解析和维护，用户无需关注内部细节，由ProjectManager自动管理：

```Plain Text

*.emf（项目包，可直接用解压软件打开，便于调试）
├─ project.json  # 核心配置文件：JSON格式，存四层数据中的明文数据+二进制文件索引
├─ data.bin      # 二进制数据文件：存网格拓扑、场量结果等大体积数据，按「数据块」划分
└─ resources/    # 资源文件夹：存外部关联文件（B-H曲线、自定义激励波形、Maxwell导入文件）
```

#### （1）project.json：核心配置文件（明文）

包含**所有明文数据**和**二进制数据块的索引信息**，是项目文件的“入口”，ProjectManager加载时先解析该文件，再根据索引读取data.bin中的对应数据块，示例结构（简化）：

```JSON

{
  "project_meta": {
    "proj_id": "Motor_001",
    "proj_name": "永磁同步电机",
    "create_time": "2026-02-05 10:00:00",
    "dim_type": "AXIS",
    "field_type": "VECTOR",
    "solver_type": "MUMPS"
  },
  "material_data": {
    "Copper_001": { "mat_name": "铜", "sigma": 5.8e7, "mat_type": "LINEAR" },
    "NdFeB_002": { "mat_name": "钕铁硼N52", "mur": 1.05, "bh_curve_path": "resources/bh_n52.dat" }
  },
  "boundary_data": {
    "Bnd_001": { "bnd_type": "NEUMANN", "link_entity_ids": ["Entity_001"], "bnd_params": { "value": 0.0 } }
  },
  "mesh_index": {  // 二进制数据块索引：数据名称→偏移量+大小
    "node_data": { "offset": 0, "size": 102400 },
    "unit_data": { "offset": 102400, "size": 204800 },
    "dof_map": { "offset": 307200, "size": 51200 }
  },
  "map_table": {  // 关联映射表
    "Entity_001": { "material_id": "Copper_001", "boundary_ids": ["Bnd_001"] },
    "Unit_001": { "entity_id": "Entity_001" }
  }
}
```

#### （2）data.bin：二进制数据文件（分块存储）

按**「数据块」** 划分，每个数据块对应网格拓扑、场量结果等一类大体积数据，在project.json中通过**偏移量（offset）和大小（size）** 索引，ProjectManager可**随机读取**指定数据块，无需加载整个文件，提升大项目的加载效率。

#### （3）resources/：资源文件夹

存储项目的**外部关联文件**，如B-H曲线（*.dat/*.txt）、自定义激励波形（*.csv）、Maxwell导入的XML文件、网格文件（*.msh）等，项目包中的所有路径均为**相对路径**，保证项目文件的**可移植性**（复制到任意路径均可正常加载）。

## 四、第三步：实现「ProjectManager单例管理器」

设计**单例模式**的ProjectManager类，作为**所有项目数据的统一入口**，屏蔽底层文件IO、序列化、格式转换、数据关联等细节，上层模块（材料、边界、网格、场型）和用户**仅通过该管理器操作数据**，保证数据的一致性和操作的统一性。

该管理器是**项目数据管理的核心**，负责**数据的加载、保存、校验、关联、增量更新**，同时与电磁模块的其他子模块（MaterialManager、BoundaryManager、MeshManager、DimensionAbstraction）无缝对接，自动同步数据。

### 1. ProjectManager核心特性

1. **单例模式**：全局唯一实例，避免多实例操作导致的数据冲突；

2. **数据缓存**：加载项目后，所有数据缓存到内存中，操作均基于内存，保存时再写入文件，提升操作效率；

3. **自动关联**：加载数据时，根据映射表自动建立「几何-材料-边界」「单元-实体-DOF」的关联，无需上层模块手动处理；

4. **增量标记**：跟踪数据的修改状态（新增/修改/删除），保存时仅更新修改的部分数据（明文+二进制数据块），无需重写整个项目包；

5. **数据校验**：加载/保存时自动校验数据的合法性（如材料参数>0、边界关联的几何ID存在、网格单元拓扑合法），非法数据抛出**统一的ProjectException**异常并提示解决方案；

6. **模块同步**：加载数据后，自动将材料数据同步到MaterialManager，边界数据同步到BoundaryManager，网格数据同步到MeshManager，维度设置同步到DimensionAbstraction，上层场型模块无需关注数据来源。

### 2. ProjectManager核心类设计（C++工程化）

包含**项目生命周期管理**的全量API，接口简洁、统一，贴合工程化使用习惯，同时支持**Maxwell兼容导入**和**框架原生导出**：

```C++

// 项目数据修改状态枚举
enum class DataState { ORIGIN, ADDED, MODIFIED, DELETED };
// 单例项目管理器类
class ProjectManager {
public:
    // 单例获取：全局唯一实例（线程安全）
    static ProjectManager& get_instance() {
        static ProjectManager instance;
        return instance;
    }

    // ===================== 项目生命周期核心API =====================
    // 1. 创建新项目：初始化空数据模型，设置基础元数据
    void create_new_project(const std::string& proj_name, DimType dim, FieldType field);
    // 2. 加载项目：从.emf项目包加载所有数据，自动校验+关联+模块同步
    bool load_project(const std::string& emf_file_path);
    // 3. 保存项目：全量保存→将内存中所有数据写入.emf项目包；增量保存→仅更新修改的部分
    bool save_project(const std::string& emf_file_path, bool is_increment = false);
    // 4. 关闭项目：清空内存缓存，释放资源
    void close_project();
    // 5. 导入Maxwell项目：解析Maxwell导出的XML/TXT，自动转换为框架数据模型
    bool import_maxwell_project(const std::string& maxwell_xml_path);
    // 6. 导出项目：将框架数据导出为Maxwell兼容XML/TXT或通用格式（VTK/Excel）
    bool export_project(const std::string& export_path, ExportFormat fmt);

    // ===================== 数据操作API（上层模块/用户调用） =====================
    // 材料数据操作
    void add_material(const MaterialData& mat);       // 添加材料
    bool modify_material(const std::string& mat_id, const MaterialData& new_mat); // 修改材料
    bool delete_material(const std::string& mat_id);  // 删除材料
    MaterialData get_material(const std::string& mat_id) const; // 获取材料
    // 边界数据操作（与材料类似）
    void add_boundary(const BoundaryData& bnd);
    bool modify_boundary(const std::string& bnd_id, const BoundaryData& new_bnd);
    bool delete_boundary(const std::string& bnd_id);
    BoundaryData get_boundary(const std::string& bnd_id) const;
    // 网格数据操作（大体积数据，单独接口）
    void set_mesh_topology(const MeshTopologyData& mesh_data); // 设置网格拓扑
    MeshTopologyData get_mesh_topology() const;                // 获取网格拓扑
    // 结果数据操作
    void add_result(const ResultData& result);       // 添加计算结果
    std::vector<ResultData> get_all_results() const; // 获取所有结果

    // ===================== 数据关联与校验API =====================
    // 建立几何-材料关联
    bool link_entity_material(const std::string& entity_id, const std::string& mat_id);
    // 建立几何-边界关联
    bool link_entity_boundary(const std::string& entity_id, const std::string& bnd_id);
    // 全量数据校验：返回校验结果+错误信息
    std::pair<bool, std::string> validate_all_data() const;

private:
    // 私有构造/析构/拷贝/赋值：禁止外部实例化和拷贝
    ProjectManager() = default;
    ~ProjectManager() = default;
    ProjectManager(const ProjectManager&) = delete;
    ProjectManager& operator=(const ProjectManager&) = delete;

    // 核心成员变量：内存缓存的项目全量数据
    ProjectMeta proj_meta_;                // 配置元数据
    CoreBusinessData core_business_data_;  // 核心业务数据
    ProcessData process_data_;             // 计算过程数据
    ResultDataList result_data_list_;      // 计算结果数据
    MapTable map_table_;                   // 关联映射表
    // 数据修改状态映射：数据类型+ID→修改状态（用于增量保存）
    std::unordered_map<std::string, DataState> data_state_map_;

    // 私有辅助方法（屏蔽底层细节）
    bool pack_emf_file(const std::string& emf_path); // 将文件打包为.emf项目包
    bool unpack_emf_file(const std::string& emf_path); // 解包.emf项目包
    void sync_to_modules(); // 将内存数据同步到MaterialManager/BoundaryManager等子模块
    void mark_data_state(const std::string& data_key, DataState state); // 标记数据修改状态
};
```

### 3. 上层模块/用户的无感知调用示例

用户/上层模块无需关注底层存储细节，仅通过ProjectManager的统一API操作数据，**一行代码实现数据的添加/修改/保存**，示例如下：

```C++

// 1. 创建新项目（轴对称+矢量场：永磁电机仿真）
ProjectManager::get_instance().create_new_project("永磁同步电机", DimType::AXIS, FieldType::VECTOR);
// 2. 添加材料（铜）
MaterialData copper;
copper.mat_id = "Copper_001";
copper.mat_name = "铜";
copper.sigma = 5.8e7;
copper.mat_type = MatType::LINEAR;
ProjectManager::get_instance().add_material(copper);
// 3. 添加边界（磁绝缘边界，关联实体Entity_001）
BoundaryData mag_insul;
mag_insul.bnd_id = "Bnd_001";
mag_insul.bnd_type = BndType::NEUMANN;
mag_insul.link_entity_ids = {"Entity_001"};
mag_insul.bnd_params = {{"value", 0.0}};
ProjectManager::get_instance().add_boundary(mag_insul);
// 4. 建立几何-材料/边界关联
ProjectManager::get_instance().link_entity_material("Entity_001", "Copper_001");
ProjectManager::get_instance().link_entity_boundary("Entity_001", "Bnd_001");
// 5. 保存项目（增量保存，首次保存自动转为全量）
ProjectManager::get_instance().save_project("motor.emf", true);
```

## 五、第四步：全生命周期数据管控（从创建到删除，全程可控）

基于上述数据模型、存储格式和ProjectManager，实现项目数据**「创建-修改-求解-保存-导入-导出」** 的全生命周期管控，解决工程化中的**增量修改、批量处理、版本兼容、数据备份**等核心需求。

### 1. 增量修改与保存（工程化高效操作）

ProjectManager通过**data_state_map_** 跟踪所有数据的修改状态（新增/修改/删除/原始），保存时仅对**修改的部分**进行序列化和写入：

- 明文数据（JSON）：仅更新project.json中修改的节点，无需重写整个文件；

- 二进制数据（bin）：仅重写修改的数据块，通过偏移量覆盖，无需重写整个二进制文件；

- 优势：对于大项目（如3D电机网格，GB级数据），增量保存可将保存时间从分钟级缩短到秒级。

### 2. 批量处理与多算例管理

支持**多项目实例的内存缓存**和**批量加载/保存/求解**，通过ProjectManager的**批量API**实现（如`batch_load_projects`、`batch_save_projects`），适配工程中的**多算例仿真**（如电机不同转速、不同激励、不同材料的批量计算）：

- 批量加载多个.emf项目文件，自动分配独立的内存缓存；

- 批量求解后，自动将结果保存到对应项目文件；

- 支持多算例结果的统一对比和导出。

### 3. 版本兼容与数据升级

项目元数据中包含**框架版本号（proj_version）**，后续框架升级时，ProjectManager可自动识别旧版本项目文件，通过**数据升级器（DataUpgrader）** 将旧版本数据模型转换为新版本：

- 旧版本缺失的字段：自动填充默认值；

- 旧版本字段类型变化：自动做类型转换；

- 旧版本数据结构变化：自动按映射规则重构，保证项目文件的**向下兼容**。

### 4. 数据备份与日志追溯

- **自动备份**：保存项目时，自动生成**备份文件（*.emf.bak）**，默认保留最近3个备份，防止项目文件损坏或误操作；

- **操作日志**：将所有数据操作（创建/添加/修改/删除/保存）记录到**project.json**的日志节点，包含操作时间、操作人、操作内容，便于工程追溯和问题排查；

- **崩溃恢复**：框架异常崩溃时，自动保存内存中未写入文件的修改数据到**临时文件（*.emf.tmp）**，重启后可恢复临时数据，避免数据丢失。

### 5. 大项目优化（按需加载/内存管理）

对于3D大型项目（如整台电机、变压器，网格节点数超100万），采用**「按需加载+内存分片」** 优化：

- 按需加载：加载项目时，仅加载配置元数据、材料、边界等小体积数据，网格拓扑、结果数据等大体积数据**按需加载**（如用户查看网格时再加载节点/单元数据）；

- 内存分片：将大体积二进制数据按**分片（slice）** 加载到内存，避免一次性加载导致的内存溢出，同时支持分片释放，提升内存利用率。

## 六、与现有架构的无缝对接（不破坏原有解耦设计）

该项目数据管理方案完全贴合前序设计的**2D/3D统一抽象架构**、**第三方求解器适配架构**、**电磁模块子模块解耦设计**，通过**ProjectManager的模块同步功能**实现无缝对接，核心对接点如下：

1. **与2D/3D维度抽象架构**：ProjectManager加载的维度类型（DimType）自动同步到DimensionAbstraction抽象基类，几何/网格数据按维度自动适配，维度抽象层仅通过ID获取数据，无需关注数据存储；

2. **与第三方求解器适配架构**：ProjectManager加载的求解器类型、并行模式、矩阵配置等数据，自动同步到ThirdPartySolverAdapter基类，第三方求解器仅通过统一接口获取参数，无需关注数据来源；

3. **与材料/边界/网格子模块**：ProjectManager加载数据后，自动将材料数据同步到MaterialManager，边界数据同步到BoundaryManager，网格数据同步到MeshManager，这些子模块仅需实现**数据接收接口**，无需修改原有逻辑；

4. **与求解器/后处理模块**：求解器计算完成后，将结果数据通过ProjectManager的`add_result` API添加到项目数据，后处理模块通过`get_all_results` API获取结果，实现**求解-结果-项目文件**的自动关联。

## 总结

电磁模块项目文件的各类数据（材料、设置、边界、网格等）的保存管理，核心是**「结构化建模定形态，双格式存储提效率，单例管理器做入口，全生命周期管流程」**，通过该方案实现的核心价值如下：

1. **数据有序**：四层结构化数据模型，让分散的各类数据按用途组织，通过唯一ID建立关联，避免数据混乱；

2. **操作便捷**：ProjectManager统一入口，屏蔽底层细节，上层仅需简单API即可实现数据的加载/保存/修改，大幅降低使用门槛；

3. **高效存储**：JSON/YAML+二进制混合存储，兼顾明文编辑和大体积数据的存储效率，单文件项目包提升可移植性；

4. **兼容扩展**：支持Maxwell导入/导出，向下兼容旧版本项目文件，新增数据类型仅需新增结构化数据类，实现无重构扩展；

5. **工程适配**：增量修改、批量处理、按需加载、自动备份等特性，完全满足工业级电磁仿真的工程化需求，对标Maxwell的项目管理体验。

该方案既解决了**数据怎么存、怎么管**的基础问题，又兼顾了**易用性、效率、兼容性、可扩展性**，是工业级电磁仿真软件项目文件管理的落地式设计。
> （注：文档部分内容可能由 AI 生成）