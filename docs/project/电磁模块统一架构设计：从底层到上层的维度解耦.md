# 电磁模块统一架构设计：从底层到上层的维度解耦

要实现电磁模块**2D/3D/2D轴对称**的统一抽象架构，核心遵循**「分层抽象+接口归一+差异下沉+工厂解耦」** 四大原则，把**维度相关的所有差异逻辑（几何、单元、积分、DOF、场量运算）** 全部封装在底层派生类中，上层通过**统一的抽象层接口**调用，让静电/静磁/瞬态磁等场型模块**完全无感知维度差异**，做到**「一次开发，多维度复用」**，同时无缝对接现有有限元框架的DOF、稀疏矩阵、求解器模块。

整个架构分为**四层**，从下到上实现维度解耦，且所有抽象均基于C++面向对象特性（抽象基类+纯虚函数+派生类实现），贴合工程化开发规范，同时兼容电磁模块的材料、边界、激励等子模块，以下是**落地式架构设计+核心实现细节+关键技术点**，完全对标Maxwell的维度适配逻辑，同时适配有限元电磁计算的核心需求。

### 一、先定核心架构分层（从下到上，差异逐层屏蔽）

整个维度抽象架构分为**四层**，层与层之间通过**统一抽象接口**通信，**禁止跨层调用**，新增维度（如后续扩展其他简化维度）仅需在最底层新增派生类，无需修改上层任何代码，完全符合**开闭原则**。

```Plain Text

┌──────────────────────── 应用层：电磁场型模块（静电/静磁/瞬态磁） ┐
│  无任何维度硬编码，仅调用抽象层统一接口，实现场离散/矩阵组装/求解  │
└──────────────────────────────────┬───────────────────────────────┘
                                   │ 调用统一抽象接口
┌──────────────────────── 抽象层：维度抽象核心层（DimensionAbstraction） ┐
│  定义所有维度相关的纯虚接口，封装通用逻辑（参数校验/日志/框架对接）  │
└──────────────────────────────────┬───────────────────────────────┘
                                   │ 派生类实现纯虚接口
┌──────────────────────── 实现层：维度专属派生类（2D/3D/AXIS） ┐
│  各自实现抽象层的纯虚接口，下沉所有维度差异逻辑（几何/单元/积分/DOF） │
│  轴对称（AXIS）继承2D派生类，复用2D逻辑+重写旋转相关接口          │
└──────────────────────────────────┬───────────────────────────────┘
                                   │ 调用底层工具
┌──────────────────────── 工具层：现有框架底层模块 ┐
│ DOF管理/稀疏矩阵/求解器/网格/内存/并行框架      │
└────────────────────────────────────────────────┘
```

**核心设计思想**：**上层只关注「做什么」，底层只关注「怎么做」**。比如应用层的静磁场模块只需要“计算单元刚度矩阵”，调用抽象层的`calc_elem_stiff_mat()`接口即可，至于2D是按面积分、3D是按体积分、轴对称是按旋转积分，完全由底层派生类实现，应用层无感知。

### 二、核心：抽象层设计（DimensionAbstraction 抽象基类）

抽象层是**维度统一的灵魂**，设计一个**纯虚抽象基类**`DimensionAbstraction`，**统一定义所有电磁有限元计算中与维度相关的核心接口**，同时封装**通用公共逻辑**（如参数校验、日志输出、框架模块对接、异常处理），让底层派生类仅需实现**差异的纯虚接口**，无需重复开发通用逻辑。

该基类的接口设计**完全围绕电磁有限元的核心流程**展开，覆盖**几何/单元/积分/DOF/场量运算/矩阵组装/结果处理**七大核心环节，与电磁模块的前处理/求解/后处理全流程一一对应，同时**严格对齐现有框架的接口规范**（如DOF管理、稀疏矩阵格式）。

#### 1. 抽象基类核心接口定义（分模块，纯虚+通用）

以下是贴合C++工程化的核心接口设计，包含**纯虚接口（底层实现）和通用接口（基类封装）**，注释明确功能与对接环节：

```C++

// 维度类型枚举（全局统一，上层仅需传入该枚举，无需关注底层）
enum class DimType { D2, D3, AXIS }; // 2D/3D/2D轴对称

// 场量类型枚举（对接场型，抽象层按需分配DOF/计算逻辑）
enum class FieldType { SCALAR, VECTOR }; // 标量场（静电）/矢量场（静磁/瞬态）

// 维度抽象核心基类（纯虚，所有维度派生类继承）
class DimensionAbstraction {
public:
    // 构造函数：传入维度类型+场量类型，基类封装通用初始化
    DimensionAbstraction(DimType dim, FieldType field) : dim_type_(dim), field_type_(field) {}
    virtual ~DimensionAbstraction() = default; // 虚析构，保证派生类析构

    // ===================== 通用接口（基类封装，上层直接调用，无维度差异） =====================
    // 初始化：对接前处理，基类封装框架模块对接（DOF/稀疏矩阵/内存）
    void init(const std::string& mesh_file); // 传入网格文件，基类调用底层parse_mesh+init_dof+init_mesh
    // 求解核心：封装有限元离散全流程，基类调用底层所有纯虚接口，组装矩阵/载荷
    void assemble_matrix(Vector& F, SparseMatrix& K); // 输出载荷向量F+刚度矩阵K，对接现有求解器
    // 后处理通用：基类封装结果映射，调用底层field_calc+result_restore
    void post_process(const Vector& X, ResultManager& result); // 输入解向量X，输出后处理结果

    // ===================== 纯虚接口（底层派生类必须实现，维度差异全部下沉此处） =====================
    // ---------- 几何/网格模块（前处理，对接网格文件解析/拓扑管理） ----------
    virtual void parse_mesh(const std::string& mesh_file) = 0; // 解析网格文件，生成维度专属拓扑结构
    virtual std::vector<EntityID> get_all_entities() = 0; // 获取所有实体ID（2D面/3D体/AXIS旋转面）
    virtual double get_entity_volume(EntityID ent_id) = 0; // 获取实体体积（2D为面积，AXIS为旋转体积）

    // ---------- 单元模块（有限元离散，对接单元库/形函数/雅可比） ----------
    virtual void init_unit_library() = 0; // 初始化维度专属单元库（2D三角/四边形，3D四面体/六面体）
    virtual UnitBase* get_unit(UnitID unit_id) = 0; // 根据单元ID获取维度专属单元实例（对接单元抽象类）
    virtual int get_unit_local_dof_num() = 0; // 获取单元局部DOF数（2D标量4个，3D矢量12个等）

    // ---------- 积分模块（有限元核心，对接高斯积分/积分运算） ----------
    virtual void init_integrator(int integ_order) = 0; // 初始化积分器，设置积分阶数
    virtual double calc_integral(const IntegrandFunc& func, UnitID unit_id) = 0; // 计算积分，传入被积函数+单元ID

    // ---------- DOF管理模块（对接现有框架，DOF映射/编号/约束） ----------
    virtual void init_dof(DOFManager& dof_mgr) = 0; // 初始化DOF，对接现有DOFManager，分配全局DOF数
    virtual std::vector<GlobalDOF> get_unit_global_dof(UnitID unit_id) = 0; // 获取单元局部-全局DOF映射

    // ---------- 场量运算模块（有限元离散，对接控制方程/场量梯度/旋度/散度） ----------
    virtual Vector calc_shape_fun(const Point& p, UnitID unit_id) = 0; // 计算形函数值（p为积分点）
    virtual Matrix calc_shape_fun_deriv(const Point& p, UnitID unit_id) = 0; // 计算形函数导数
    virtual Vector calc_field_gradient(const Vector& u, UnitID unit_id) = 0; // 计算场量梯度（u为单元局部解）
    virtual double calc_field_curl(const Vector& u, UnitID unit_id) = 0; // 计算场量旋度（2D标量，3D矢量的模）
    virtual double calc_jacobian_det(const Point& p, UnitID unit_id) = 0; // 计算雅可比行列式（积分必备）

    // ---------- 矩阵组装模块（求解核心，单元刚度矩阵/载荷向量计算） ----------
    virtual Matrix calc_elem_stiff_mat(UnitID unit_id, MaterialParam mat) = 0; // 计算单元刚度矩阵
    virtual Vector calc_elem_load_vec(UnitID unit_id, ExcitationParam exc) = 0; // 计算单元载荷向量

    // ---------- 结果处理模块（后处理，维度专属结果计算/还原） ----------
    virtual Vector calc_field_value(const Vector& X, const Point& p, UnitID unit_id) = 0; // 计算点场量值
    virtual void restore_3d_result(ResultManager& result) = 0; // 3D结果还原（AXIS将2D结果转3D，D2/3D直接返回）

protected:
    // 通用成员变量（基类封装，底层派生类可访问）
    DimType dim_type_;          // 维度类型
    FieldType field_type_;      // 场量类型
    DOFManager* dof_mgr_;       // 现有框架DOF管理指针
    SparseMatrix* sparse_mat_;  // 现有框架稀疏矩阵指针
    MeshData* mesh_data_;       // 网格数据通用指针（底层派生类实现具体类型）
};
```

#### 2. 基类通用接口的核心作用

基类中`init()`、`assemble_matrix()`、`post_process()`等**通用接口**是**上层场型模块的唯一调用入口**，其核心作用是：

- 封装**有限元全流程的逻辑串接**，比如`assemble_matrix()`会按“遍历所有单元→调用底层`calc_elem_stiff_mat()`→组装全局刚度矩阵→调用`calc_elem_load_vec()`→组装全局载荷向量”的固定逻辑执行，底层仅需实现单元级的计算接口；

- 封装**现有框架的模块对接**，比如`init()`会自动初始化现有框架的`DOFManager`、`SparseMatrix`，底层派生类无需关注框架细节，仅需实现DOF/矩阵的维度专属初始化；

- 封装**参数校验/异常处理**，比如基类会提前校验网格文件格式、积分阶数、材料参数的合法性，非法参数直接抛出统一的`DimException`异常，底层派生类无需重复校验。

### 三、实现层设计：维度专属派生类（2D/3D/AXIS）

实现层是**维度差异的具体落地**，设计三个派生类：`D2Dimension`（2D）、`D3Dimension`（3D）、`AxisDimension`（2D轴对称），**全部继承** **`DimensionAbstraction`** **抽象基类**，实现所有纯虚接口，**下沉所有维度相关的差异逻辑**。

#### 1. 派生类设计原则

1. **轴对称复用2D逻辑**：轴对称本质是**2D平面旋转后的简化计算**，因此`AxisDimension`**直接继承** **`D2Dimension`**，仅重写**旋转相关的接口**（如`calc_integral()`加旋转因子、`get_entity_volume()`计算旋转体积、`restore_3d_result()`将2D结果转3D），复用2D的90%以上代码，避免冗余；

2. **严格遵循接口规范**：所有派生类实现纯虚接口时，**输入/输出参数严格对齐基类定义**，比如`calc_elem_stiff_mat()`的返回值必须是`Matrix`类型，且维度与单元局部DOF数一致，确保基类通用接口能无缝调用；

3. **仅关注维度差异**：派生类中**不包含任何场型相关逻辑**（如静电场的介电常数、静磁场的磁导率），场型参数仅作为**函数入参**传入，由上层场型模块传递，实现**维度与场型的完全解耦**；

4. **对接现有框架数据结构**：派生类中所有DOF、稀疏矩阵、向量的类型，**完全使用现有框架的定义**（如`GlobalDOF`、`SparseMatrix`），无需重新定义，确保与框架的无缝对接。

#### 2. 核心维度差异的实现细节（关键痛点解决）

以下是电磁有限元中**2D/3D/AXIS最核心的维度差异**，以及派生类的具体实现方式，覆盖有限元离散的核心环节：

|核心环节|2D派生类实现|3D派生类实现|轴对称派生类实现（继承2D，重写）|
|---|---|---|---|
|**几何拓扑**|实体=面，拓扑=面-边-节点|实体=体，拓扑=体-面-边-节点|实体=旋转面，复用2D拓扑+记录旋转轴/旋转角|
|**单元库**|三角/四边形（线性/二次）标量/矢量元|四面体/六面体（线性/二次）矢量元|复用2D单元库+标记旋转单元|
|**积分运算**|面积分（2D高斯积分）/线积分|体积分（3D高斯积分）/面积分|**重写**：面积分×旋转因子 $2\pi r$ （r为径向坐标），转1D积分|
|**DOF分配**|标量场=节点DOF，矢量场=棱边DOF（2维）|所有场型=棱边DOF（3维，规避伪解）|复用2D DOF+旋转分量映射|
|**雅可比计算**|2D雅可比矩阵（2×2），行列式=面积因子|3D雅可比矩阵（3×3），行列式=体积因子|复用2D雅可比+乘旋转因子 $r$ |
|**场量运算**|旋度=标量（垂直纸面），梯度=2D矢量|旋度=3D矢量，梯度=3D矢量|复用2D场量运算+旋转分量还原（如B的周向分量）|
|**矩阵组装**|刚度矩阵=2×2/4×4（标量/矢量单元）|刚度矩阵=3×3/12×12（矢量单元）|复用2D矩阵+乘旋转因子，载荷向量同步缩放|
|**结果处理**|直接输出2D云图/矢量图|输出3D云图/矢量图，支持切面/剖面|**重写**：2D结果×旋转角，生成3D旋转云图/矢量图|
#### 3. 轴对称的关键优化实现（工程化必备）

轴对称是电磁模块的**工程化核心优化**（将3D计算量降低80%），其派生类的重写核心是**「2D计算+旋转因子+3D结果还原」**，以下是核心接口的重写示例（C++伪代码）：

```C++

// 2D轴对称派生类，继承2D派生类
class AxisDimension : public D2Dimension {
public:
    AxisDimension(FieldType field) : D2Dimension(DimType::AXIS, field) {
        rot_axis_ = Point(0,0,0); // 默认旋转轴Z轴，用户可配置
        rot_angle_ = 2 * M_PI;    // 全周旋转，支持部分旋转（如电机1/4模型）
    }

    // 重写积分计算：2D面积分 × 旋转因子2πr（r为积分点径向坐标）
    double calc_integral(const IntegrandFunc& func, UnitID unit_id) override {
        double d2_integ = D2Dimension::calc_integral(func, unit_id); // 调用2D积分结果
        Point p = get_integral_centroid(unit_id); // 获取积分点形心
        double r = sqrt(p.x*p.x + p.y*p.y); // 径向坐标（旋转轴Z轴）
        return d2_integ * 2 * M_PI * r; // 旋转积分因子
    }

    // 重写实体体积计算：2D面积 × 2πr
    double get_entity_volume(EntityID ent_id) override {
        double d2_area = D2Dimension::get_entity_volume(ent_id); // 2D面积
        Point cent = get_entity_centroid(ent_id); // 实体形心
        double r = sqrt(cent.x*cent.x + cent.y*cent.y);
        return d2_area * 2 * M_PI * r;
    }

    // 重写3D结果还原：将2D计算结果旋转为3D云图/矢量图
    void restore_3d_result(ResultManager& result) override {
        ResultData d2_result = result.get_2d_result(); // 获取2D计算结果
        ResultData d3_result;
        // 2D点旋转为3D点：极坐标转换（r,θ,z）→ 直角坐标（x,y,z）
        for (auto& [p2d, val] : d2_result.field_data) {
            for (double theta = 0; theta < rot_angle_; theta += 0.1) { // 旋转采样
                Point p3d;
                p3d.x = p2d.x * cos(theta);
                p3d.y = p2d.x * sin(theta);
                p3d.z = p2d.y;
                d3_result.field_data[p3d] = val; // 场量值不变，仅坐标旋转
            }
        }
        result.set_3d_result(d3_result); // 设置3D结果，对接后处理
    }

private:
    Point rot_axis_;  // 旋转轴
    double rot_angle_;// 旋转角
};
```

### 四、上层调用与工厂模式：维度一键切换（无感知）

为了让上层**场型模块/用户**完全无需关注底层派生类的创建与管理，设计**「工厂模式+统一配置」**，实现**维度的一键切换**，用户仅需传入`DimType`枚举（如`DimType::D3`）或在配置文件中设置`dimension: 3D`，即可自动创建对应的维度实例，上层所有操作均通过**抽象基类指针**完成，**无任何维度硬编码**。

#### 1. 维度工厂类设计（DimensionFactory）

工厂类是**上层与抽象层的唯一入口**，封装所有维度派生类的创建逻辑，提供**静态创建接口**，根据维度类型自动返回`DimensionAbstraction`抽象基类的智能指针（避免内存泄漏），工程化推荐使用`std::unique_ptr`：

```C++

// 维度工厂类（单例模式，避免多次创建）
class DimensionFactory {
public:
    // 单例获取：全局唯一工厂实例
    static DimensionFactory& get_instance() {
        static DimensionFactory instance;
        return instance;
    }

    // 核心创建接口：传入维度类型+场量类型，返回抽象基类智能指针
    std::unique_ptr<DimensionAbstraction> create_dim(DimType dim_type, FieldType field_type) {
        switch (dim_type) {
            case DimType::D2:
                return std::make_unique<D2Dimension>(field_type);
            case DimType::D3:
                return std::make_unique<D3Dimension>(field_type);
            case DimType::AXIS:
                return std::make_unique<AxisDimension>(field_type);
            default:
                throw std::invalid_argument("Unsupported dimension type!");
        }
    }

    // 重载接口：从配置文件读取维度类型，对接工程化配置
    std::unique_ptr<DimensionAbstraction> create_dim_from_config(const Config& cfg) {
        DimType dim = cfg.get<DimType>("dimension");
        FieldType field = cfg.get<FieldType>("field_type");
        return create_dim(dim, field);
    }

private:
    // 私有构造，禁止外部实例化（单例）
    DimensionFactory() = default;
    ~DimensionFactory() = default;
    // 禁止拷贝/赋值
    DimensionFactory(const DimensionFactory&) = delete;
    DimensionFactory& operator=(const DimensionFactory&) = delete;
};
```

#### 2. 上层场型模块的无感知调用示例（静磁场模块）

以下是**静磁场模块**的核心调用代码，**无任何维度相关的硬编码**，仅通过工厂类创建抽象基类指针，调用通用接口即可完成全流程，切换维度仅需修改**配置文件/传入的DimType枚举**，代码完全无需改动：

```C++

// 静磁场模块（上层应用层，无维度硬编码）
class Magnetostatic {
public:
    Magnetostatic(const Config& cfg) {
        // 1. 从配置文件创建维度抽象实例（一键切换维度，仅改配置）
        dim_ptr_ = DimensionFactory::get_instance().create_dim_from_config(cfg);
        // 2. 初始化材料/边界/激励（与维度解耦，仅按实体ID赋值）
        mat_mgr_.load_material(cfg.get<std::string>("material_file"));
        bnd_mgr_.load_boundary(cfg.get<std::string>("boundary_file"));
        exc_mgr_.load_excitation(cfg.get<std::string>("excitation_file"));
    }

    // 静磁场求解全流程（无维度差异）
    void solve() {
        // 1. 前处理初始化：调用抽象层通用接口
        dim_ptr_->init(cfg.get<std::string>("mesh_file"));
        // 2. 组装刚度矩阵K和载荷向量F：调用抽象层通用接口
        Vector F;
        SparseMatrix K;
        dim_ptr_->assemble_matrix(F, K);
        // 3. 对接现有求解器：无维度差异，直接调用框架求解器
        Solver* solver = SolverFactory::get_instance().create_solver(cfg);
        Vector X = solver->solve(K, F); // X为解向量（矢量磁势A）
        // 4. 后处理：调用抽象层通用接口，自动还原维度专属结果
        ResultManager result;
        dim_ptr_->post_process(X, result);
        // 5. 工程指标计算（与维度解耦，调用抽象层get_entity_volume等接口）
        calc_engineering_index(result);
    }

private:
    std::unique_ptr<DimensionAbstraction> dim_ptr_; // 维度抽象指针（核心）
    MaterialManager mat_mgr_;                       // 材料管理（与维度解耦）
    BoundaryManager bnd_mgr_;                       // 边界管理（与维度解耦）
    ExcitationManager exc_mgr_;                     // 激励管理（与维度解耦）
    Config cfg_;                                    // 配置文件
};
```

#### 3. 配置文件统一（工程化用户入口）

提供**JSON/YAML统一配置文件**，用户仅需修改`dimension`字段，即可实现2D/3D/AXIS的一键切换，无需修改任何代码，贴合工程化用户的使用习惯：

```YAML

# 电磁模块统一配置文件（yaml格式）
electro_mag:
  dimension: AXIS        # 维度：D2/D3/AXIS，一键切换
  field_type: VECTOR     # 场量类型：SCALAR（静电）/VECTOR（静磁/瞬态）
  mesh_file: "motor.msh" # 网格文件（通用格式，底层自动解析）
  material_file: "material.json"
  boundary_file: "boundary.json"
  excitation_file: "excitation.json"
  solve_param:
    tol: 1e-6            # 收敛精度
    max_iter: 1000       # 最大迭代次数
```

### 五、与电磁模块其他子模块的无缝解耦

二维三维统一抽象架构的核心优势之一是**与电磁模块的材料、边界、激励、Project文件、后处理等子模块完全解耦**，这些子模块**无需任何维度相关的代码**，仅需通过**抽象层提供的统一拓扑ID（实体/面/边ID）**进行操作，由抽象层底层自动将ID映射为维度专属的几何对象。

以**材料管理模块**为例，其仅需按**实体ID**为材料赋值，无需关注该实体是2D的面、3D的体还是轴对称的旋转面：

```C++

// 材料管理模块（无维度代码）
mat_mgr_.assign_material(ent_id=1, mat_name="Copper"); // 为实体ID=1赋值铜
// 抽象层底层自动映射：
// D2：实体ID=1 → 2D面；D3：实体ID=1 → 3D体；AXIS：实体ID=1 → 旋转面
```

边界/激励模块同理，仅需按**面/边ID**添加约束/激励，抽象层底层自动处理维度差异，实现**所有子模块与维度的完全解耦**，大幅减少代码冗余。

### 六、架构核心优势与工程化扩展

该统一抽象架构完全贴合**工业级电磁仿真软件的设计规范**（对标Maxwell/ANSYS），同时适配有限元框架的开发需求，核心优势如下：

1. **完全解耦维度与场型**：维度差异全部下沉到实现层，场型模块无需任何维度硬编码，一次开发即可在2D/3D/AXIS上复用；

2. **代码复用率极高**：轴对称继承2D，复用90%以上代码，新增维度仅需新增派生类，实现层对上层无侵入；

3. **维度一键切换**：用户仅需修改配置文件或传入枚举，即可切换维度，上层代码完全无需改动；

4. **框架无缝对接**：所有接口均对齐现有框架的DOF、稀疏矩阵、求解器模块，无需重新定义底层数据结构；

5. **工程化易扩展**：预留**高频电磁/多物理场耦合**的接口扩展，仅需在抽象层新增纯虚接口，底层派生类按需实现即可。

#### 工程化扩展方向

1. **新增简化维度**：如**平面波导/柱面波导**等简化维度，仅需新增派生类，继承抽象基类实现纯虚接口，上层无感知；

2. **单元类型扩展**：如新增**高阶单元（三次/四次）**，仅需在单元库抽象层新增单元类型，底层派生类实现对应的形函数/导数即可；

3. **多物理场耦合**：在抽象层新增**热/结构场的接口**（如`calc_heat_source()`计算电磁损耗热源），底层派生类实现维度专属的热源计算，对接热模块。

### 总结

二维三维统一抽象架构的**核心本质**是**「将维度差异作为实现细节，通过抽象层提供统一的有限元计算接口」**，通过**分层抽象+接口归一+差异下沉+工厂解耦**四大原则，让上层场型模块、材料/边界等子模块完全无需关注维度差异，实现**「一次开发，多维度复用」**。

整个架构的**关键落地点**是：

1. 抽象层基类**全覆盖电磁有限元全流程**的纯虚接口，与前处理/求解/后处理一一对应；

2. 轴对称**继承2D派生类**，复用逻辑并仅重写旋转相关接口；

3. 工厂模式**封装维度实例创建**，实现上层无感知的维度一键切换；

4. 所有子模块**通过统一拓扑ID与抽象层交互**，实现与维度的完全解耦。

该架构不仅解决了维度带来的代码冗余问题，更让电磁模块的**可维护性、可扩展性、工程化程度**大幅提升，完全满足工业级电磁仿真软件的设计需求。
> （注：文档部分内容可能由 AI 生成）