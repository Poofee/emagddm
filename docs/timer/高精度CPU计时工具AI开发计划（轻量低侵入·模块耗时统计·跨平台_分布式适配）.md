# 高精度CPU计时工具AI开发计划（轻量低侵入·模块耗时统计·跨平台/分布式适配）

## 一、开发整体目标

AI需实现一款**轻量级、高精度、低侵入性**的CPU计时工具，核心支撑C++有限元框架（DOF管理、稀疏矩阵、FETI-DP等模块）的**单步耗时测量、模块全生命周期耗时统计**，满足工程开发中的性能调优、瓶颈定位需求。最终工具需达成以下核心指标：

1. 计时精度：**纳秒级（ns）** 核心计时，跨平台（Linux/Windows）误差≤1μs，计时自身CPU开销＜1%；

2. 统计能力：支持模块耗时的**累计、调用次数、平均/最大/最小耗时、总占比**多维度统计，支持全局统一管理；

3. 易用性：**宏封装低侵入接入**，模块计时仅需在代码首尾加2行宏，无需修改业务逻辑；

4. 适配性：原生支持**单线程/多线程/分布式MPI**场景，兼容C++17，与现有框架（内存管理、稀疏矩阵、DOF管理）无缝协同；

5. 工程化：支持耗时单位自动转换、统计结果多端输出（控制台/日志/文件）、开关可配，支持Python绑定查看统计结果。

## 二、核心设计原则与技术栈约定

### 1. 核心设计原则（计时工具专属，AI严格遵循）

|原则|具体要求|
|---|---|
|**高精度**|基于C++17标准`std::chrono`高精度时钟，处理跨平台时钟差异，保证纳秒级计时基准|
|**低侵入**|优先宏封装+轻量类，业务代码接入计时无需修改逻辑，仅需新增宏标记，支持一键关闭计时|
|**低开销**|计时核心逻辑（启动/停止/统计）为纯内存操作，无IO/动态内存分配，自身开销可忽略|
|**线程安全**|多线程场景下，模块统计无数据竞争，支持单线程独立统计、全局合并结果|
|**统计灵活**|支持模块名唯一绑定，多维度统计指标，支持按模块名/耗时排序/过滤查询|
|**跨平台**|兼容Linux（GCC/Clang）、Windows（MSVC），屏蔽系统底层时钟API差异|
|**可扩展**|预留接口支持自定义统计指标、自定义输出格式、对接第三方监控工具|
### 2. 技术栈与协同约定

- 核心语言：C++17（与现有框架版本一致，禁止更高版本）；

- 计时底层：基于`std::chrono`（`high_resolution_clock`/`steady_clock`，处理跨平台兼容），禁止直接调用系统底层API（如Linux`clock_gettime`、Windows`QueryPerformanceCounter`）；

- 线程安全：基于C++17`std::mutex`/`std::atomic`实现，多线程统计用原子操作减少锁开销；

- 分布式适配：基于现有MPI框架（`MPICommWrapper`），实现进程统计结果汇总；

- 内存管理：轻量设计，核心数据结构（统计信息）为栈上/预分配内存，无需调用内存管理工具，避免过度依赖；

- 日志/输出：适配现有`spdlog`日志系统，支持统计结果输出到日志/控制台/文件；

- 编码规范：与现有框架一致（类名`UpperCamelCase`、函数/变量`lower_snake_case`），关键逻辑加注释，代码无冗余。

### 3. 核心适用场景（贴合现有框架）

- 单步功能计时：如DOF编号生成、界面DOF提取、稀疏矩阵组装的单次耗时测量；

- 模块全周期统计：如`DofNumberer`、`CooMatrix`、`InterfaceDofExtractor`等模块的累计调用耗时、平均耗时；

- 多线程性能调优：如分布式矩阵组装中各线程的模块耗时统计，定位线程负载不均问题；

- 分布式性能汇总：如FETI-DP多进程下，各进程核心模块的耗时对比、全局平均/最大耗时统计；

- 瓶颈定位：通过模块耗时占比排序，快速定位框架中CPU占用最高的核心模块。

## 三、分阶段开发计划（4阶段递进，独立模块·可分步集成）

### 阶段1：基础高精度CPU计时（核心底层，适配单步计时）

#### 阶段目标

实现**跨平台纳秒级基础计时**，封装轻量`Timer`核心类，提供启动、停止、重置、耗时获取等基础接口，实现极简宏封装，完成跨平台（Linux/Windows）兼容性处理，为后续模块统计打基础。

#### 核心开发任务（AI具体操作）

1. **跨平台时钟封装**

    - 实现`timer_clock.h`，定义跨平台高精度时钟别名`HighResClock`，屏蔽`std::chrono`在Linux/Windows的时钟差异（如Windows`high_resolution_clock`为系统时钟，需替换为`steady_clock`保证单调递增）；

    - 定义时钟时间点`TimePoint`、耗时类型`Duration`（基于`std::chrono::nanoseconds`），封装基础时间操作。

2. **基础计时类** **`Timer`** **实现**

    - 实现`timer.h/cpp`，定义轻量类`Timer`，无依赖、无动态内存分配，核心成员仅**时间点+是否运行标记**；

    - 实现核心接口：

        - `start()`：启动计时（记录当前时间点，重复启动无副作用）；

        - `stop()`：停止计时（累计耗时，重复停止无副作用）；

        - `reset()`：重置所有状态（耗时归0，标记为未运行）；

        - `get_elapsed_ns()`：获取总耗时（纳秒，核心接口）；

        - `is_running()`：判断计时是否在运行中；

    - 类内所有接口为**内联函数**，减少函数调用开销。

3. **低侵入宏封装**

    - 基于`Timer`实现极简全局宏，如`TIMER_GLOBAL_START`、`TIMER_GLOBAL_STOP`、`TIMER_GLOBAL_GET_ELAPSED`；

    - 宏为**条件编译**，定义`TIMER_ENABLE`为1时启用，0时直接空展开，实现一键关闭计时，无任何开销。

4. **跨平台测试用例开发**

    - 编写`test_timer_basic.cpp`，实现跨平台测试逻辑（判断编译环境为Linux/Windows）；

    - 测试用例包含：基础计时准确性（对比已知耗时操作，如循环1e6次）、重复启动/停止鲁棒性、重置功能、一键关闭计时的开销验证；

    - 验证指标：纳秒级计时误差≤1μs，空计时（关闭`TIMER_ENABLE`）开销为0。

#### 技术要求（AI必须满足）

1. 跨平台：Linux（GCC9+）、Windows（MSVC2019+）编译通过，计时结果一致，无时钟跳变（单调递增）；

2. 精度：纯计时操作（启动+停止）耗时＜10ns，测量1ms固定耗时的误差≤1μs；

3. 轻量：`Timer`类内存占用≤64字节（适配缓存行），无堆内存分配，无外部依赖；

4. 鲁棒性：重复启动/停止、未启动直接获取耗时等边界场景，无崩溃、无乱码，返回合理值（如0）。

#### 交付物

1. 头文件：`timer_clock.h`、`timer.h`（含宏定义）；

2. 源文件：`timer.cpp`；

3. 测试用例：`test_timer_basic.cpp`（含跨平台测试逻辑）；

4. 临时文档：`timer_basic_api.md`（说明基础类+宏的使用方法）。

#### 测试验证标准

1. 功能正确性：启动/停止/重置/获取耗时功能正常，边界场景无异常；

2. 精度达标：纳秒级计时误差≤1μs，纯计时开销＜10ns；

3. 跨平台：Linux/Windows编译运行无错误，计时结果偏差＜5%；

4. 一键关闭：定义`TIMER_ENABLE=0`后，所有计时宏空展开，编译无警告，运行无额外开销。

---

### 阶段2：模块耗时统计（核心功能，适配工程性能统计）

#### 阶段目标

在基础`Timer`之上，实现**模块级耗时多维度统计**，封装`StatisticsTimer`（绑定模块名）+ 全局`TimerManager`（统一管理所有模块），提供**一行宏接入**的模块统计能力，支持多维度统计指标和全局查询/打印，实现**线程安全**（多线程模块统计无数据竞争）。

#### 核心开发任务（AI具体操作）

1. **统计数据结构定义**

    - 在`timer_stat.h`中定义`ModuleStat`结构体，存储单个模块的全量统计指标，**所有成员为原子类型**（保证线程安全）：

        ```C++
        
        struct ModuleStat {
            std::atomic<uint64_t> call_count = 0;    // 模块调用次数
            std::atomic<uint64_t> total_ns = 0;      // 累计耗时（ns）
            std::atomic<uint64_t> min_ns = ULLONG_MAX;// 最小耗时（ns）
            std::atomic<uint64_t> max_ns = 0;        // 最大耗时（ns）
            double avg_ns() const;                   // 平均耗时（内联计算）
        };
        ```

2. **模块统计计时类** **`StatisticsTimer`** **实现**

    - 继承基础`Timer`，新增**模块名**成员，绑定唯一模块标识（如`"DofNumberer::generate_dofs"`）；

    - 重写`stop()`接口：停止计时后，自动将耗时更新到对应模块的`ModuleStat`中，同时更新调用次数、最大/最小耗时；

    - 实现**局部模块统计**，支持多线程独立实例，无全局锁竞争。

3. **全局统计管理器** **`TimerManager`** **实现**

    - 实现单例模式`TimerManager`（全局唯一，避免多实例冲突），核心存储`std::unordered_map<std::string, ModuleStat>`（模块名→统计信息）；

    - 实现核心接口：

        - `register_module(const std::string& module_name)`：注册模块（首次统计自动注册，无需手动调用）；

        - `get_stat(const std::string& module_name)`：按模块名查询统计信息；

        - `get_all_stats()`：获取所有模块的统计信息（返回有序列表）；

        - `sort_by_total()`/`sort_by_avg()`：按累计/平均耗时排序统计结果；

        - `print_stats()`：格式化打印所有模块统计结果（控制台）；

        - `reset_all()`：重置所有模块的统计信息；

    - 所有写操作（更新统计）用**原子操作**，读操作（查询/打印）加轻量读锁，保证线程安全且开销最小。

4. **低侵入模块统计宏封装（核心易用性）**

    - 实现一键式模块统计宏，**用户仅需在模块首尾加宏**，自动完成计时+统计，无需创建对象：

        ```C++
        
        #define TIMER_MODULE_BEGIN(module_name) \
            static thread_local StatisticsTimer _stat_timer(module_name); \
            _stat_timer.start();
        #define TIMER_MODULE_END(module_name) \
            _stat_timer.stop();
        ```

    - 宏使用**线程局部存储（thread_local）**，每个线程独立创建`StatisticsTimer`实例，避免多线程竞争，提升性能。

5. **模块统计测试用例开发**

    - 编写`test_timer_stat.cpp`，测试单线程/多线程下的模块统计；

    - 测试场景：单个模块多次调用、多模块并行统计、多线程同模块统计，验证统计指标（累计/平均/最大/最小）的准确性；

    - 验证线程安全：多线程高并发调用（10线程×1e6次），统计结果无数据错乱、无内存泄漏。

#### 技术要求（AI必须满足）

1. 线程安全：多线程（≥10）高并发统计，`ModuleStat`所有指标无错乱、无重复/缺失；

2. 低侵入：模块统计仅需2行宏，无需修改业务代码，宏展开无编译警告；

3. 统计准确性：累计耗时=单次耗时之和，平均/最大/最小耗时计算无误差；

4. 性能：单模块单次统计（启动+停止）开销＜20ns，1e6次统计总开销＜20ms；

5. 鲁棒性：未注册模块自动注册，重复注册无副作用，查询不存在的模块返回空统计（无崩溃）。

#### 交付物

1. 新增/更新文件：`timer_stat.h/cpp`、更新`timer.h/cpp`（新增`StatisticsTimer`）；

2. 测试用例：`test_timer_stat.cpp`（单线程+多线程测试）；

3. 文档更新：`timer_api.md`（新增模块统计类+宏的使用方法，附示例）。

#### 测试验证标准

1. 统计准确性：单线程/多线程下，模块累计耗时、调用次数与实际一致，平均/最大/最小耗时计算正确；

2. 线程安全：多线程高并发统计无数据错乱，无死锁、无内存泄漏；

3. 易用性：宏接入模块统计后，编译运行无错误，统计结果可正常查询/打印；

4. 性能：模块统计自身开销＜业务代码的1%，无性能瓶颈。

---

### 3. 阶段3：多线程/分布式适配+功能增强（工程化必备）

#### 阶段目标

实现**多线程统计合并、分布式MPI适配**，新增**耗时单位自动转换、统计过滤、批量输出**等工程化功能，让工具适配有限元框架的多线程/分布式场景，同时提升使用便捷性。

#### 核心开发任务（AI具体操作）

1. **多线程统计结果合并优化**

    - 扩展`TimerManager`，新增`merge_thread_stats()`接口，支持将所有线程的模块统计结果合并为全局统计；

    - 实现**线程局部统计→全局统计**的自动合并，无需用户手动调用，保证多线程场景下全局统计的完整性。

2. **分布式MPI场景适配**

    - 基于现有框架的`MPICommWrapper`，实现分布式计时统计：

        - 各进程**独立统计**本地模块耗时，无跨进程通信（避免计时干扰）；

        - 根进程（rank=0）提供`gather_all_process_stats()`接口，通过MPI`Gather`汇总所有进程的模块统计信息；

        - 根进程实现**全局统计计算**：按模块名计算所有进程的平均耗时、最大耗时、最小耗时，格式化打印分布式统计结果；

    - 实现**MPI无感适配**：非分布式场景（单进程）下，分布式接口自动空展开，无编译/运行错误。

3. **工程化功能增强（核心易用性）**

    - **耗时单位自动转换**：新增`format_duration(uint64_t ns)`接口，根据耗时大小自动转换为`ns/μs/ms/s`（如＜1μs显示ns，1μs~1ms显示μs），所有打印/查询结果均自动适配；

    - **统计过滤功能**：扩展`TimerManager`，新增`filter_by_threshold(uint64_t min_ns)`接口，过滤掉累计耗时低于阈值的模块，避免高频小模块占用统计资源；

    - **批量输出接口**：新增`export_stats_to_file(const std::string& file_path)`接口，将统计结果以CSV格式导出到文件，支持后续Excel/Matlab分析；

    - **模块耗时占比计算**：扩展`ModuleStat`，新增`total_ratio(double global_total_ns)`接口，计算单个模块耗时占所有模块总耗时的百分比，快速定位性能瓶颈。

4. **多线程/分布式测试用例开发**

    - 扩展`test_timer_stat.cpp`，新增多线程统计合并测试；

    - 编写`test_timer_distributed.cpp`，基于MPI实现2/4/8进程分布式测试，验证各进程统计、根进程汇总、全局统计计算的准确性；

    - 测试功能增强：验证单位自动转换、统计过滤、CSV导出的正确性。

#### 技术要求（AI必须满足）

1. 分布式一致性：MPI多进程（≥8）下，根进程能正确汇总所有进程的统计信息，全局平均/最大/最小耗时计算无误差；

2. 单位转换：耗时在ns/μs/ms/s区间内转换准确，无格式错误，打印结果清晰易读；

3. 分布式开销：MPI汇总统计的通信开销＜总计时的5%，不影响业务模块性能；

4. 兼容性：多线程/分布式功能均为可选，单线程/单进程场景下无额外开销，接口调用无冲突。

#### 交付物

1. 新增/更新文件：`timer_distributed.h/cpp`、更新`timer_stat.h/cpp`/`timer.h/cpp`；

2. 测试用例：`test_timer_distributed.cpp`（MPI分布式测试）、扩展`test_timer_stat.cpp`；

3. 文档更新：`timer_api.md`（新增分布式接口、功能增强接口的使用方法）。

#### 测试验证标准

1. 分布式统计：多进程下各进程本地统计准确，根进程汇总无遗漏，全局统计指标计算正确；

2. 功能增强：单位自动转换准确，统计过滤能正确屏蔽小耗时模块，CSV导出格式规范（可直接用Excel打开）；

3. 兼容性：单进程/多进程、单线程/多线程场景下，所有接口均能正常使用，无编译/运行错误。

---

### 4. 阶段4：工程化集成与优化（最终落地，适配现有框架）

#### 阶段目标

完成计时工具的**性能极致优化、现有框架集成、日志/配置/Python绑定**，实现**无感知接入、可配置开关、多端输出**，最终成为有限元框架的基础性能工具，满足工程化使用要求。

#### 核心开发任务（AI具体操作）

1. **计时开销极致优化**

    - 对所有核心接口（`start()`/`stop()`/统计更新）做**极致内联**，消除函数调用开销；

    - 优化`TimerManager`的存储结构，将`std::unordered_map`替换为`std::flat_hash_map`（更快的哈希表），提升模块查询效率；

    - 实现**计时开关的编译期/运行期双支持**：

        - 编译期：定义`TIMER_ENABLE=0`，所有计时代码空展开，无任何开销；

        - 运行期：新增`TimerManager::enable(bool flag)`接口，支持运行时动态开启/关闭计时，无需重新编译；

    - 性能验证：计时工具自身的CPU开销＜业务代码的1%，大规模调用（1e9次）无性能瓶颈。

2. **与现有框架深度集成**

    - **日志系统集成**：适配现有`spdlog`日志框架，将`print_stats()`/`export_stats_to_file()`的输出接入日志，支持按日志级别（INFO/DEBUG）输出统计结果；

    - **现有模块接入测试**：将计时宏接入**DOF管理、稀疏矩阵、界面DOF提取**的核心模块（如`DofNumberer::generate_dofs`、`CooMatrix::assemble`、`InterfaceDofExtractor::extract_all_interface_dofs`），验证低侵入性和统计准确性；

    - **内存管理协同**：核心统计数组（如`ModuleStat`列表）通过现有`CacheLineAligner`做缓存行对齐，提升统计查询效率。

3. **工程化扩展（配置/Python绑定）**

    - **JSON配置文件支持**：实现`timer_config.h/cpp`，支持从JSON配置文件读取参数：

        - 计时开关（enable）、统计阈值（filter_threshold）；

        - 输出格式（console/log/file）、CSV导出路径；

        - 分布式汇总是否开启（gather_stats）；

    - **Python绑定实现**：使用`pybind11`封装`TimerManager`的核心接口（`get_stat`/`get_all_stats`/`print_stats`），实现Python脚本调用C++计时工具，查看/分析统计结果；

    - **全局初始化接口**：新增`TimerManager::init(const std::string& config_path)`接口，实现计时工具的一键初始化，无需手动配置参数。

4. **全流程集成测试与文档完善**

    - 编写`test_timer_integration.cpp`，实现计时工具与DOF管理、稀疏矩阵模块的全流程集成测试，跑通**标量元DOF编号→稀疏矩阵组装→界面DOF提取**的完整流程，验证统计结果的准确性和低侵入性；

    - 完善代码注释：所有类/接口/宏均添加详细注释，保证代码可维护性；

    - 编写完整工程化文档：`timer_user_manual.md`（包含工具介绍、API详解、宏使用示例、配置文件说明、Python绑定用法、常见问题）；

    - 整理测试用例：保证测试覆盖率≥95%，覆盖基础计时、模块统计、多线程、分布式、集成场景。

#### 技术要求（AI必须满足）

1. 性能优化：计时工具自身CPU开销＜1%，1e9次启动/停止操作耗时＜10s；

2. 低侵入集成：接入现有核心模块后，框架编译运行无错误，业务逻辑无任何改变；

3. 配置灵活：JSON配置文件能正确解析所有参数，运行时动态开关计时无副作用；

4. Python绑定：Python能正常调用C++计时工具的所有核心接口，统计结果传输无误差；

5. 可维护性：代码模块化，注释完整，文档详细，后续扩展（如新增统计指标）无需修改核心逻辑。

#### 交付物

1. 新增/更新文件：`timer_config.h/cpp`、`timer_python_bind.cpp`、更新所有现有头文件/源文件；

2. 测试用例：`test_timer_integration.cpp`（全框架集成测试）、完善所有现有测试用例；

3. 工程化文档：`timer_user_manual.md`（完整使用手册）、`timer_api.md`（最新API详解）；

4. 配置文件：`timer_config.json`（默认配置文件，含详细注释）；

5. 集成示例：`timer_integration_example.cpp`（现有模块接入计时的示例代码）。

#### 测试验证标准

1. 集成性：计时工具能无缝接入现有框架核心模块，统计结果能准确反映模块实际耗时，无统计偏差；

2. 性能：接入计时后，框架整体性能下降＜1%，无明显卡顿；

3. 工程化：配置文件解析正确，Python绑定调用正常，日志/控制台/文件输出均清晰规范；

4. 完整性：测试覆盖率≥95%，所有功能无bug，文档能支撑用户快速接入和使用。

## 四、AI开发核心注意事项（必遵循）

1. **低侵入低开销优先**：计时工具的核心价值是“测量性能”，而非“消耗性能”，任何功能实现都需以**低侵入、低开销**为前提，禁止为了功能复杂而牺牲性能；

2. **跨平台兼容贯穿全程**：开发过程中需同时验证Linux/Windows的编译和运行，禁止使用平台专属语法/API，确保跨平台一致性；

3. **线程安全无死角**：所有涉及多线程的代码（如`ModuleStat`、`TimerManager`）必须用原子操作/轻量锁，禁止裸写共享变量，开发后必须做高并发线程测试；

4. **测试驱动开发**：每个功能实现后，立即编写对应测试用例，覆盖正常场景、边界场景、异常场景，禁止堆积bug到后续阶段；

5. **与现有框架协同无侵入**：接入现有框架时，仅通过宏/独立接口调用，禁止修改现有框架的核心代码，禁止增加现有框架的依赖；

6. **编译期/运行期双开关**：必须实现计时的编译期（空展开）和运行期（动态开关）双支持，满足“开发时统计性能，生产时关闭计时”的工程需求；

7. **代码简洁模块化**：计时工具为基础工具，代码需简洁、模块化，禁止过度设计，后续扩展（如新增监控对接）需通过预留接口实现，不修改核心逻辑。

## 五、最终交付物目录结构（独立模块，与现有框架解耦）

计时工具为**独立可编译模块**，与DOF管理、稀疏矩阵模块解耦，可单独测试、维护、集成，最终交付目录结构如下（符合现有框架规范）：

```Plain Text

timer/
├── include/
│   ├── timer_clock.h        // 跨平台高精度时钟封装
│   ├── timer.h              // 基础Timer+StatisticsTimer类
│   ├── timer_stat.h         // 模块统计结构+TimerManager
│   ├── timer_distributed.h  // 分布式MPI适配接口
│   ├── timer_config.h       // JSON配置文件解析
│   └── timer.h              // 汇总头文件，一键引入所有接口
├── src/
│   ├── timer.cpp
│   ├── timer_stat.cpp
│   ├── timer_distributed.cpp
│   └── timer_config.cpp
├── python/
│   └── timer_python_bind.cpp // Python绑定实现
├── test/
│   ├── test_timer_basic.cpp     // 基础计时+跨平台测试
│   ├── test_timer_stat.cpp      // 模块统计+多线程测试
│   ├── test_timer_distributed.cpp // 分布式MPI测试
│   └── test_timer_integration.cpp // 现有框架集成测试
├── config/
│   └── timer_config.json     // 默认JSON配置文件
├── doc/
│   ├── timer_api.md          // 详细API说明
│   └── timer_user_manual.md  // 完整使用手册
└── example/
    └── timer_integration_example.cpp // 现有模块接入示例
```

## 六、后续扩展方向（阶段4完成后，可选实现）

1. 新增**CPU使用率统计**：结合系统API（如Linux`/proc/stat`、Windows`PerformanceCounter`），统计模块的CPU使用率，而非仅耗时；

2. 新增**耗时趋势监控**：实现模块耗时的实时趋势记录，支持导出为时序数据（如Prometheus格式），对接第三方监控平台；

3. 新增**多进程耗时可视化**：将分布式MPI的统计结果导出为可视化图表（如热力图/柱状图），直观展示各进程性能差异；

4. 适配**GPU计时**：扩展接口支持CUDA/OpenCL的GPU计时，实现CPU/GPU耗时的统一统计管理；

5. 新增**函数级细粒度计时**：基于C++20概念/宏，实现函数级的自动计时，无需手动加宏标记。
> （注：文档部分内容可能由 AI 生成）